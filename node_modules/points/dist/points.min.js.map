{"version":3,"file":null,"sources":["../src/arcToBezier.js","../src/helpers.js","../src/cubify.js","../src/add.js","../src/length.js","../src/decurve.js","../src/boundingBox.js","../src/moveIndex.js","../src/offset.js","../src/position.js","../src/remove.js","../src/reverse.js","../src/rotate.js","../src/scale.js"],"sourcesContent":["// I extracted this from the a2c function from\n// SVG path – https://github.com/fontello/svgpath\n//\n// All credit goes to:\n//\n// Sergey Batishchev – https://github.com/snb2013\n// Vitaly Puzrin – https://github.com/puzrin\n// Alex Kocharin – https://github.com/rlidwka\n\nconst TAU = Math.PI * 2\n\nconst mapToEllipse = ({ x, y }, rx, ry, cosphi, sinphi, centerx, centery) => {\n  x *= rx\n  y *= ry\n\n  const xp = cosphi * x - sinphi * y\n  const yp = sinphi * x + cosphi * y\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  }\n}\n\nconst approxUnitArc = (ang1, ang2) => {\n  const a = 4 / 3 * Math.tan(ang2 / 4)\n\n  const x1 = Math.cos(ang1)\n  const y1 = Math.sin(ang1)\n  const x2 = Math.cos(ang1 + ang2)\n  const y2 = Math.sin(ang1 + ang2)\n\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ]\n}\n\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = (ux * vy - uy * vx < 0) ? -1 : 1\n  const umag = Math.sqrt(ux * ux + uy * uy)\n  const vmag = Math.sqrt(ux * ux + uy * uy)\n  const dot = ux * vx + uy * vy\n\n  let div = dot / (umag * vmag)\n\n  if (div > 1) {\n    div = 1\n  }\n\n  if (div < -1) {\n    div = -1\n  }\n\n  return sign * Math.acos(div)\n}\n\nconst getArcCenter = (\n  px,\n  py,\n  cx,\n  cy,\n  rx,\n  ry,\n  largeArcFlag,\n  sweepFlag,\n  sinphi,\n  cosphi,\n  pxp,\n  pyp\n) => {\n  const rxsq = Math.pow(rx, 2)\n  const rysq = Math.pow(ry, 2)\n  const pxpsq = Math.pow(pxp, 2)\n  const pypsq = Math.pow(pyp, 2)\n\n  let radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq)\n\n  if (radicant < 0) {\n    radicant = 0\n  }\n\n  radicant /= (rxsq * pypsq) + (rysq * pxpsq)\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1)\n\n  const centerxp = radicant * rx / ry * pyp\n  const centeryp = radicant * -ry / rx * pxp\n\n  const centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2\n  const centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2\n\n  const vx1 = (pxp - centerxp) / rx\n  const vy1 = (pyp - centeryp) / ry\n  const vx2 = (-pxp - centerxp) / rx\n  const vy2 = (-pyp - centeryp) / ry\n\n  let ang1 = vectorAngle(1, 0, vx1, vy1)\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2)\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU\n  }\n\n  return [ centerx, centery, ang1, ang2 ]\n}\n\nconst arcToBezier = ({\n  px,\n  py,\n  cx,\n  cy,\n  rx,\n  ry,\n  xAxisRotation = 0,\n  largeArcFlag = 0,\n  sweepFlag = 0\n}) => {\n  const curves = []\n\n  if (rx === 0 || ry === 0) {\n    return []\n  }\n\n  const sinphi = Math.sin(xAxisRotation * TAU / 360)\n  const cosphi = Math.cos(xAxisRotation * TAU / 360)\n\n  const pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2\n  const pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2\n\n  if (pxp === 0 && pyp === 0) {\n    return []\n  }\n\n  rx = Math.abs(rx)\n  ry = Math.abs(ry)\n\n  const lambda =\n    Math.pow(pxp, 2) / Math.pow(rx, 2) +\n    Math.pow(pyp, 2) / Math.pow(ry, 2)\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda)\n    ry *= Math.sqrt(lambda)\n  }\n\n  let [ centerx, centery, ang1, ang2 ] = getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinphi,\n    cosphi,\n    pxp,\n    pyp\n  )\n\n  const segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1)\n\n  ang2 /= segments\n\n  for (let i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2))\n    ang1 += ang2\n  }\n\n  return curves.map(curve => {\n    const { x: x1, y: y1 } = mapToEllipse(curve[ 0 ], rx, ry, cosphi, sinphi, centerx, centery)\n    const { x: x2, y: y2 } = mapToEllipse(curve[ 1 ], rx, ry, cosphi, sinphi, centerx, centery)\n    const { x, y } = mapToEllipse(curve[ 2 ], rx, ry, cosphi, sinphi, centerx, centery)\n\n    return { x1, y1, x2, y2, x, y }\n  })\n}\n\nexport default arcToBezier\n","const angleFromSides = (a, b, c) => {\n  const r = Math.acos(\n    (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) /\n    (2 * a * b)\n  )\n\n  return r * (180 / Math.PI)\n}\n\nconst applyFuncToShapes = (f, s, ...args) => {\n  if (isShapeArray(s)) {\n    return s.map(shape => f(shape, ...args))\n  }\n\n  return f(s, ...args)\n}\n\nconst getShapeArray = s => isShapeArray(s) ? s : [ s ]\n\nconst isShapeArray = s => Array.isArray(s[ 0 ])\n\nconst numberAtInterval = (a, b, interval) => {\n  const c = a === b ? 0 : Math.abs(b - a)\n  return c === 0 ? a : (a < b ? a + c * interval : a - c * interval)\n}\n\nexport {\n  angleFromSides,\n  applyFuncToShapes,\n  getShapeArray,\n  isShapeArray,\n  numberAtInterval\n}\n","import arcToBezier from './arcToBezier'\nimport { applyFuncToShapes } from './helpers'\n\nconst cubifyShape = shape => {\n  const s = []\n\n  for (let i = 0, l = shape.length; i < l; i++) {\n    const point = shape[ i ]\n\n    if (point.curve && point.curve.type !== 'cubic') {\n      const { x: px, y: py } = shape[ i - 1 ]\n      const { x: cx, y: cy } = point\n\n      if (point.curve.type === 'arc') {\n        const curves = arcToBezier({\n          px,\n          py,\n          cx,\n          cy,\n          rx: point.curve.rx,\n          ry: point.curve.ry,\n          xAxisRotation: point.curve.xAxisRotation,\n          largeArcFlag: point.curve.largeArcFlag,\n          sweepFlag: point.curve.sweepFlag\n        })\n\n        curves.forEach(({ x1, y1, x2, y2, x, y }) => {\n          s.push({ x, y, curve: { type: 'cubic', x1, y1, x2, y2 } })\n        })\n      } else if (point.curve.type === 'quadratic') {\n        const x1 = px + (2 / 3 * (point.curve.x1 - px))\n        const y1 = py + (2 / 3 * (point.curve.y1 - py))\n        const x2 = cx + (2 / 3 * (point.curve.x1 - cx))\n        const y2 = cy + (2 / 3 * (point.curve.y1 - cy))\n\n        s.push({ x: cx, y: cy, curve: { type: 'cubic', x1, y1, x2, y2 } })\n      }\n    } else {\n      s.push(point)\n    }\n  }\n\n  return s\n}\n\nconst cubify = s => applyFuncToShapes(cubifyShape, s)\n\nexport default cubify\n","import cubify from './cubify'\nimport { numberAtInterval } from './helpers'\n\nconst linearPoints = (from, to) => [\n  {\n    x: numberAtInterval(from.x, to.x, 0.5),\n    y: numberAtInterval(from.y, to.y, 0.5)\n  },\n  to\n]\n\nconst curvedPoints = (from, to) => {\n  const { x1, y1, x2, y2 } = to.curve\n\n  const A = { x: from.x, y: from.y }\n  const B = { x: x1, y: y1 }\n  const C = { x: x2, y: y2 }\n  const D = { x: to.x, y: to.y }\n  const E = { x: numberAtInterval(A.x, B.x, 0.5), y: numberAtInterval(A.y, B.y, 0.5) }\n  const F = { x: numberAtInterval(B.x, C.x, 0.5), y: numberAtInterval(B.y, C.y, 0.5) }\n  const G = { x: numberAtInterval(C.x, D.x, 0.5), y: numberAtInterval(C.y, D.y, 0.5) }\n  const H = { x: numberAtInterval(E.x, F.x, 0.5), y: numberAtInterval(E.y, F.y, 0.5) }\n  const J = { x: numberAtInterval(F.x, G.x, 0.5), y: numberAtInterval(F.y, G.y, 0.5) }\n  const K = { x: numberAtInterval(H.x, J.x, 0.5), y: numberAtInterval(H.y, J.y, 0.5) }\n\n  return [\n    { x: K.x, y: K.y, curve: { type: 'cubic', x1: E.x, y1: E.y, x2: H.x, y2: H.y } },\n    { x: D.x, y: D.y, curve: { type: 'cubic', x1: J.x, y1: J.y, x2: G.x, y2: G.y } }\n  ]\n}\n\nconst points = (from, to) => to.curve\n  ? curvedPoints(from, to)\n  : linearPoints(from, to)\n\nconst addPoints = (shape, pointsRequired) => {\n  if (isNaN(pointsRequired)) {\n    throw Error('`add` function must be passed a number as the second argument')\n  }\n\n  const nextShape = [ ...shape ]\n\n  for (let i = 1; i < nextShape.length;) {\n    if (nextShape.length >= pointsRequired) {\n      return nextShape\n    }\n\n    const to = nextShape[ i ]\n\n    if (to.moveTo) {\n      i++\n    } else {\n      const from = nextShape[ i - 1 ]\n      const [ midPoint, replacementPoint ] = points(from, to)\n\n      nextShape.splice(i, 1, midPoint, replacementPoint)\n\n      i += 2\n    }\n  }\n\n  return addPoints(nextShape, pointsRequired)\n}\n\nconst add = (shape, pointsRequired) => addPoints(cubify(shape), pointsRequired)\n\nexport { curvedPoints }\nexport default add\n","import decurve from './decurve'\n\nconst length = (shape, accuracy) => {\n  const s = decurve(shape, accuracy)\n\n  return s.reduce((currentLength, { x: x2, y: y2, moveTo }, i) => {\n    if (!moveTo) {\n      const { x: x1, y: y1 } = s[ i - 1 ]\n      currentLength += linearLength(x1, y1, x2, y2)\n    }\n\n    return currentLength\n  }, 0)\n}\n\nconst linearLength = (x1, y1, x2, y2) => Math.sqrt(\n  Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)\n)\n\nexport { linearLength }\nexport default length\n","import { angleFromSides } from './helpers'\nimport cubify from './cubify'\nimport { curvedPoints } from './add'\nimport { linearLength } from './length'\n\nconst angle = triangle => {\n  const [ ax, ay ] = triangle[ 0 ]\n  const [ bx, by ] = triangle[ 1 ]\n  const [ cx, cy ] = triangle[ 2 ]\n\n  const a = linearLength(ax, ay, bx, by)\n  const b = linearLength(bx, by, cx, cy)\n  const c = linearLength(cx, cy, ax, ay)\n\n  return angleFromSides(a, b, c)\n}\n\nconst curved = shape => shape.reduce((c, { curve }) => curve ? true : c, false)\n\nconst decurve = (shape, accuracy = 1) => {\n  if (!curved(shape)) {\n    return shape\n  }\n\n  const s = cubify(shape)\n  const d = []\n\n  s.map((point, i) => {\n    if (point.curve) {\n      const prevPoint = s[ i - 1 ]\n      straighten(prevPoint, point, accuracy)\n        .map(p => d.push(p))\n    } else {\n      d.push(point)\n    }\n  })\n\n  return d\n}\n\nconst straight = (x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy) => {\n  const t1 = [[ cx1, cy1 ], [ x2, y2 ], [ x1, y1 ]]\n  const t2 = [[ cx2, cy2 ], [ x1, y1 ], [ x2, y2 ]]\n  return angle(t1) < accuracy && angle(t2) < accuracy\n}\n\nconst straighten = (prevPoint, point, accuracy) => {\n  const { x: x1, y: y1 } = prevPoint\n  const { x: x2, y: y2, curve } = point\n  const { x1: cx1, y1: cy1, x2: cx2, y2: cy2 } = curve\n\n  if (straight(x1, y1, cx1, cy1, x2, y2, cx2, cy2, accuracy)) {\n    return [ point ]\n  }\n\n  const [ midPoint, lastPoint ] = curvedPoints(prevPoint, point)\n\n  return [\n    ...straighten(prevPoint, midPoint, accuracy),\n    ...straighten(midPoint, lastPoint, accuracy)\n  ]\n}\n\nexport default decurve\n","import decurve from './decurve'\nimport { getShapeArray } from './helpers'\n\nconst boundingBox = s => {\n  let bottom\n  let left\n  let right\n  let top\n\n  const shapes = getShapeArray(s)\n\n  shapes.map(shape => decurve(shape).map(({ x, y }) => {\n    if (typeof bottom !== 'number' || y > bottom) {\n      bottom = y\n    }\n\n    if (typeof left !== 'number' || x < left) {\n      left = x\n    }\n\n    if (typeof right !== 'number' || x > right) {\n      right = x\n    }\n\n    if (typeof top !== 'number' || y < top) {\n      top = y\n    }\n  }))\n\n  return {\n    bottom,\n    center: {\n      x: left + ((right - left) / 2),\n      y: top + ((bottom - top) / 2)\n    },\n    left,\n    right,\n    top\n  }\n}\n\nexport default boundingBox\n","const countLinePoints = lines => lines.reduce((count, points) => (\n  count + countPoints(points)\n), 0)\n\nconst countPoints = points => points.length - (isJoined(points) ? 1 : 0)\n\nconst isJoined = points => {\n  const firstPoint = points[ 0 ]\n  const lastPoint = points[ points.length - 1 ]\n  return firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y\n}\n\nconst joinLines = lines => lines.reduce((shape, line) => (\n  [ ...shape, ...line ]\n), [])\n\nconst moveIndex = (shape, offset) => {\n  const lines = splitLines(shape)\n  const count = countLinePoints(lines)\n  const normalisedOffset = ((offset % count) + count) % count\n\n  if (!normalisedOffset) {\n    return shape\n  }\n\n  const { lineIndex, pointIndex } = nextIndex(lines, normalisedOffset)\n  const reorderedLines = reorderLines(lines, lineIndex)\n  const firstLine = reorderPoints(reorderedLines[ 0 ], pointIndex)\n  const restOfLines = [ ...reorderedLines ].splice(1)\n\n  return joinLines([ firstLine, ...restOfLines ])\n}\n\nconst nextIndex = (lines, offset) => {\n  for (let i = 0, l = lines.length; i < l; i++) {\n    const count = countPoints(lines[ i ])\n\n    if (offset <= count - 1) {\n      return {\n        lineIndex: i,\n        pointIndex: offset\n      }\n    }\n\n    offset -= count\n  }\n}\n\nconst reorderLines = (lines, offset) => [ ...lines ]\n  .splice(offset)\n  .concat([ ...lines ].splice(0, offset))\n\nconst reorderPoints = (points, offset) => {\n  if (!offset) {\n    return points\n  }\n\n  const nextPoints = [\n    { x: points[ offset ].x, y: points[ offset ].y, moveTo: true },\n    ...[ ...points ].splice(offset + 1)\n  ]\n\n  if (isJoined(points)) {\n    return [\n      ...nextPoints,\n      ...[ ...points ].splice(1, offset)\n    ]\n  }\n\n  return [\n    ...nextPoints,\n    ...[ ...points ].splice(0, offset + 1)\n  ]\n}\n\nconst splitLines = shape => shape.reduce((lines, point) => {\n  if (point.moveTo) {\n    lines.push([])\n  }\n\n  lines[ lines.length - 1 ].push(point)\n\n  return lines\n}, [])\n\nexport default moveIndex\n","import { applyFuncToShapes } from './helpers'\n\nconst offsetPoints = (shape, x, y) => shape.map(point => {\n  const p = { ...point }\n\n  p.x += x\n  p.y += y\n\n  if (p.curve) {\n    p.curve = { ...p.curve }\n\n    if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {\n      p.curve.x1 += x\n      p.curve.y1 += y\n    }\n\n    if (p.curve.type === 'cubic') {\n      p.curve.x2 += x\n      p.curve.y2 += y\n    }\n  }\n\n  return p\n})\n\nconst offset = (s, x = 0, y = 0) => applyFuncToShapes(offsetPoints, s, x, y)\n\nexport default offset\n","import decurve from './decurve'\nimport length, { linearLength } from './length'\nimport { angleFromSides, numberAtInterval } from './helpers'\n\nconst angle = (x1, y1, x2, y2, a) => {\n  if (x1 === x2) {\n    return y1 >= y2 ? 0 : 180\n  }\n\n  const b = 100\n  const c = linearLength(x2, y2, x1, y1 - b)\n  const ang = angleFromSides(a, b, c)\n\n  return x1 < x2 ? ang : 360 - ang\n}\n\nconst over = (shape, length, totalLength, desiredLength) => {\n  const { x: x1, y: y1 } = shape[ length - 2 ]\n  const { x: x2, y: y2 } = shape[ length - 1 ]\n  const segmentLength = linearLength(x1, y1, x2, y2)\n  const segmentInterval = (desiredLength - totalLength) / segmentLength + 1\n  return { x1, y1, x2, y2, segmentInterval, segmentLength }\n}\n\nconst position = (shape, interval, accuracy) => {\n  const s = decurve(shape, accuracy)\n  const l = s.length\n  const t = length(s)\n  const d = t * interval\n\n  const { x1, y1, x2, y2, segmentInterval, segmentLength } =\n    interval > 1 ? over(s, l, t, d)\n      : (interval < 0 ? under(s, d) : within(s, l, d))\n\n  return {\n    angle: angle(x1, y1, x2, y2, segmentLength),\n    x: numberAtInterval(x1, x2, segmentInterval),\n    y: numberAtInterval(y1, y2, segmentInterval)\n  }\n}\n\nconst under = (shape, desiredLength) => {\n  const { x: x1, y: y1 } = shape[ 0 ]\n  const { x: x2, y: y2 } = shape[ 1 ]\n  const segmentLength = linearLength(x1, y1, x2, y2)\n  const segmentInterval = desiredLength / segmentLength\n  return { x1, y1, x2, y2, segmentInterval, segmentLength }\n}\n\nconst within = (shape, length, desiredLength) => {\n  let currentLength = 0\n\n  for (let i = 0; i < length; i++) {\n    const { moveTo } = shape[ i ]\n\n    if (!moveTo) {\n      const { x: x1, y: y1 } = shape[ i - 1 ]\n      const { x: x2, y: y2 } = shape[ i ]\n\n      const segmentLength = linearLength(x1, y1, x2, y2)\n\n      if (currentLength + segmentLength >= desiredLength) {\n        const segmentInterval = (desiredLength - currentLength) / segmentLength\n        return { x1, y1, x2, y2, segmentInterval, segmentLength }\n      }\n\n      currentLength += segmentLength\n    }\n  }\n}\n\nexport default position\n","import { applyFuncToShapes } from './helpers'\n\nconst isBetween = (a, b, c) => {\n  if (b.curve || c.curve) {\n    return false\n  }\n\n  const crossProduct =\n    (c.y - a.y) *\n    (b.x - a.x) -\n    (c.x - a.x) *\n    (b.y - a.y)\n\n  if (Math.abs(crossProduct) > Number.EPSILON) {\n    return false\n  }\n\n  const dotProduct =\n    (c.x - a.x) *\n    (b.x - a.x) +\n    (c.y - a.y) *\n    (b.y - a.y)\n\n  if (dotProduct < 0) {\n    return false\n  }\n\n  const squaredLengthBA =\n    (b.x - a.x) *\n    (b.x - a.x) +\n    (b.y - a.y) *\n    (b.y - a.y)\n\n  if (dotProduct > squaredLengthBA) {\n    return false\n  }\n\n  return true\n}\n\nconst removePoints = shape => {\n  const s = []\n\n  for (let i = 0, l = shape.length; i < l; i++) {\n    const a = s[ s.length - 1 ]\n    const b = shape[ i + 1 ]\n    const c = shape[ i ]\n\n    if (!(a && b && c) || !(isBetween(a, b, c))) {\n      s.push(c)\n    }\n  }\n\n  return s\n}\n\nconst remove = s => applyFuncToShapes(removePoints, s)\n\nexport default remove\n","import cubify from './cubify'\nimport { applyFuncToShapes } from './helpers'\n\nconst reversePoints = shape => {\n  let m\n  let c\n\n  return shape.reverse().map(({ x, y, moveTo, curve }, i) => {\n    const point = { x, y }\n\n    if (c) {\n      const { x1: x2, y1: y2, x2: x1, y2: y1 } = c\n      point.curve = { type: 'cubic', x1, y1, x2, y2 }\n    }\n\n    if (i === 0 || m) {\n      point.moveTo = true\n    }\n\n    m = moveTo\n    c = curve || null\n\n    return point\n  })\n}\n\nconst reverse = s => applyFuncToShapes(reversePoints, cubify(s))\n\nexport default reverse\n","import { applyFuncToShapes } from './helpers'\nimport boundingBox from './boundingBox'\n\nconst rotatePoint = (x, y, c, s, about) => {\n  const { x: offsetX, y: offsetY } = about\n  const relativeX = x - offsetX\n  const relativeY = y - offsetY\n\n  return [\n    (relativeX * c - relativeY * s) + offsetX,\n    (relativeX * s + relativeY * c) + offsetY\n  ]\n}\n\nconst rotatePoints = (shape, angle, about) => shape.map(point => {\n  const r = angle * Math.PI / 180\n  const c = Math.cos(r)\n  const s = Math.sin(r)\n  const [ x, y ] = rotatePoint(point.x, point.y, c, s, about)\n  const p = { ...point, x, y }\n\n  if (p.curve) {\n    if (p.curve.type === 'quadratic' || p.curve.type === 'cubic') {\n      const [ x1, y1 ] = rotatePoint(p.curve.x1, p.curve.y1, c, s, about)\n      p.curve = { ...p.curve, x1, y1 }\n    }\n\n    if (p.curve.type === 'cubic') {\n      const [ x2, y2 ] = rotatePoint(p.curve.x2, p.curve.y2, c, s, about)\n      p.curve = { ...p.curve, x2, y2 }\n    }\n  }\n\n  return p\n})\n\nconst rotate = (s, angle) => {\n  const { center: about } = boundingBox(s)\n  return applyFuncToShapes(rotatePoints, s, angle, about)\n}\n\nexport default rotate\n","import boundingBox from './boundingBox'\nimport { applyFuncToShapes } from './helpers'\n\nconst scalePoint = (point, scaleFactor, anchorX, anchorY) => {\n  const p = { ...point }\n\n  p.x = anchorX - ((anchorX - p.x) * scaleFactor)\n  p.y = anchorY - ((anchorY - p.y) * scaleFactor)\n\n  if (point.curve) {\n    p.curve = { ...p.curve }\n\n    if (p.curve.type === 'arc') {\n      if (p.curve.rx) {\n        p.curve.rx = p.curve.rx * scaleFactor\n      }\n\n      if (p.curve.ry) {\n        p.curve.ry = p.curve.ry * scaleFactor\n      }\n    } else {\n      p.curve.x1 = anchorX - ((anchorX - p.curve.x1) * scaleFactor)\n      p.curve.y1 = anchorY - ((anchorY - p.curve.y1) * scaleFactor)\n\n      if (p.curve.type === 'cubic') {\n        p.curve.x2 = anchorX - ((anchorX - p.curve.x2) * scaleFactor)\n        p.curve.y2 = anchorY - ((anchorY - p.curve.y2) * scaleFactor)\n      }\n    }\n  }\n\n  return p\n}\n\nconst scale = (s, scaleFactor, anchor = 'center') => {\n  const { bottom, center, left, right, top } = boundingBox(s)\n\n  let anchorX = center.x\n  let anchorY = center.y\n\n  switch (anchor) {\n    case 'topLeft':\n      anchorX = left\n      anchorY = top\n      break\n    case 'topRight':\n      anchorX = right\n      anchorY = top\n      break\n    case 'bottomRight':\n      anchorX = right\n      anchorY = bottom\n      break\n    case 'bottomLeft':\n      anchorX = left\n      anchorY = bottom\n      break\n  }\n\n  return applyFuncToShapes(shape => shape.map(point => {\n    return scalePoint(point, scaleFactor, anchorX, anchorY)\n  }), s)\n}\n\nexport default scale\n"],"names":["TAU","Math","PI","mapToEllipse","rx","ry","cosphi","sinphi","centerx","centery","x","y","xp","yp","approxUnitArc","ang1","ang2","a","tan","x1","cos","y1","sin","x2","y2","vectorAngle","ux","uy","vx","vy","sign","umag","sqrt","vmag","dot","div","acos","getArcCenter","px","py","cx","cy","largeArcFlag","sweepFlag","pxp","pyp","rxsq","pow","rysq","pxpsq","pypsq","radicant","centerxp","centeryp","vx1","vy1","vx2","vy2","arcToBezier","xAxisRotation","curves","abs","lambda","segments","max","ceil","i","push","map","curve","angleFromSides","b","c","r","applyFuncToShapes","f","s","args","isShapeArray","shape","getShapeArray","Array","isArray","numberAtInterval","interval","cubifyShape","l","length","point","type","forEach","cubify","linearPoints","from","to","curvedPoints","A","B","C","D","E","F","G","H","J","K","points","addPoints","pointsRequired","isNaN","Error","nextShape","moveTo","midPoint","replacementPoint","splice","add","accuracy","decurve","reduce","currentLength","linearLength","angle","triangle","ax","ay","bx","by","curved","d","prevPoint","p","straight","cx1","cy1","cx2","cy2","t1","t2","straighten","lastPoint","boundingBox","bottom","left","right","top","shapes","countLinePoints","lines","count","countPoints","isJoined","firstPoint","joinLines","line","moveIndex","offset","splitLines","normalisedOffset","nextIndex","lineIndex","pointIndex","reorderedLines","reorderLines","firstLine","reorderPoints","restOfLines","concat","nextPoints","offsetPoints","ang","over","totalLength","desiredLength","segmentLength","segmentInterval","position","t","under","within","isBetween","crossProduct","Number","EPSILON","dotProduct","squaredLengthBA","removePoints","remove","reversePoints","m","reverse","rotatePoint","about","offsetX","offsetY","relativeX","relativeY","rotatePoints","rotate","center","scalePoint","scaleFactor","anchorX","anchorY","scale","anchor"],"mappings":"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"}